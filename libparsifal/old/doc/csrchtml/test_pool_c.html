<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
	<title>samples\misc\test_pool.c</title>
	<link rel="stylesheet" type="text/css" href="highlight.css">
</head>
<body>
<pre><span class="com">/* Example that uses XMLVector, XMLStringbuf and XMLPool
   Reads lines into memory from stdin and presents them backwards
*/</span>
<span class="dir">#include &lt;stdio.h&gt;
</span><span class="dir">#include &lt;stdlib.h&gt;
</span><span class="dir">#include &lt;string.h&gt;
</span><span class="dir">#include </span><span class="dstr">&quot;libparsifal/xmlvect.h&quot;</span><span class="dir">
</span><span class="dir">#include </span><span class="dstr">&quot;libparsifal/xmlsbuf.h&quot;</span><span class="dir"> </span><span class="com">/* includes XMLPool too */</span><span class="dir">
</span>
<span class="dir">#define CHKMEM(p) if (!(p)) { puts(</span><span class="dstr">&quot;memory allocation failure!&quot;</span><span class="dir">); exit(EXIT_FAILURE); }
</span><span class="dir">#define SIZE_LINEBUF 1024
</span><span class="dir">#define SIZE_POOLITEM 30
</span>
<span class="typ">int </span>main(<span class="typ">int </span>argc, <span class="typ">char</span>* argv[])
{
  <span class="typ">char </span>linebuf[SIZE_LINEBUF];
  <span class="typ">char </span>*s;
  LPXMLPOOL pool;
  LPXMLVECTOR list;
  LPXMLSTRINGBUF sbuf;

  <span class="com">/* create a list of stringbuffers (lines) that will be allocated
     dynamically by calling XMLVector_Append(list, NULL).
     Vector grows in 6 * sizeof(XMLSTRINGBUF) sized chunks */</span>
  XMLVector_Create(&amp;list, <span class="num">6</span>, <span class="key">sizeof</span>(XMLSTRINGBUF));
  CHKMEM(list);

  <span class="com">/* create a pool for XMLStringbuf that contains SIZE_POOLITEM sized
     fixed length strings, pool grows in 4 * SIZE_POOLITEM sized chunks */</span>
  pool = XMLPool_Create(SIZE_POOLITEM, <span class="num">4</span>);
  CHKMEM(pool);

  <span class="key">while </span>(!feof(stdin)) {
    fgets(linebuf, SIZE_LINEBUF, stdin);

    <span class="com">/* append new XMLStringbuf to list: */</span>
    sbuf = XMLVector_Append(list, NULL);
    CHKMEM(sbuf);

    <span class="com">/* initialize it to use pool as long as string fits into
       pool itemsize, otherwise XMLStringbuf will allocate
       more memory from heap. XMLStringbuf grows in SIZE_POOLITEM
       sized chunks. */</span>
    s = XMLStringbuf_InitUsePool(sbuf, SIZE_POOLITEM, <span class="num">0</span>, pool);
    CHKMEM(s);

    <span class="com">/* append string into stringbuf. (You can set debugger breakpoint
       into XMLStringbuf_Append to see how memory gets allocated) */</span>
    s = XMLStringbuf_Append(sbuf, linebuf, strlen(linebuf)+<span class="num">1</span>);
    CHKMEM(s);
  }

  <span class="com">/* present the strings backwards: */</span>
  <span class="key">if </span>(list-&gt;length) {
    <span class="typ">int </span>i = list-&gt;length<span class="num">-1</span>;
    <span class="key">while </span>(i--) {
      sbuf = XMLVector_Get(list, i);
      CHKMEM(sbuf);
      printf(<span class="str">&quot;line %d: %s&quot;</span>, i+<span class="num">1</span>, sbuf-&gt;str);
      XMLStringbuf_Free(sbuf);
    }
  }

  <span class="com">/* clean up: */</span>
  _XMLVector_RemoveAll(list);
  XMLVector_Free(list);
  XMLPool_FreePool(pool);
  <span class="key">return </span><span class="num">0</span>;
}
</pre>
</body>
</html>
<!--HTML generated by highlight 2.0-17, http://www.andre-simon.de/-->
